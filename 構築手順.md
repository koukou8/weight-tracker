# Rails 8 + SQLite + Firebase Hosting で低コストアプリ構築手順

この手順では、Rails 8の新機能であるSQLite本番対応と、Google CloudのCloud Run、Cloud Storage、そしてFirebase Hostingを組み合わせて、ほぼ無料で運用できるWebアプリケーションの構築方法を解説します。

## 構成概要

この構成では以下のサービスを使用します：

- **Rails 8**: SQLiteを本番環境で使用
- **Google Cloud Run**: バックエンドアプリケーションの実行環境
- **Google Cloud Storage**: SQLiteデータベースファイルの保存先
- **Firebase Hosting**: フロントエンドの静的ファイル配信

この構成の特徴は以下の通りです：
- SQLiteをデータベースとして使用するため、Cloud SQLなどの追加費用が不要
- Cloud RunとCloud Storageの無料枠を活用
- Firebase Hostingの無料枠でフロントエンドを配信

## 前提条件

- Google Cloudアカウント
- Firebaseプロジェクト（Google Cloudと連携）
- Ruby 3.2以上
- Docker
- gcloudコマンドラインツール
- Firebaseコマンドラインツール

## 1. Railsアプリケーションの作成

### 1.1 アプリケーションの初期化

```bash
mkdir myApp
cd myApp
bundle init
```

### 1.2 GemfileにRails 8を指定

```ruby
# frozen_string_literal: true

source "https://rubygems.org"

gem "rails", "8.0.1"
```

### 1.3 Rails newでアプリケーション作成

```bash
bundle exec rails new .
```

デフォルトでDBはSQLiteとなり、storageディレクトリにSQLiteのデータが保存されます。

### 1.4 サンプル機能の作成（投稿機能）

```bash
bundle exec rails g scaffold post content:text
```

### 1.5 ルートパスの設定

`config/routes.rb`を編集します：

```ruby
Rails.application.routes.draw do
  resources :posts
  root "posts#index"
end
```

### 1.6 データベース設定の確認

`config/database.yml`を確認します。以下のようにstorageディレクトリ以下にSQLiteのデータが保存される設定になっているはずです：

```yaml
default: &default
  adapter: sqlite3
  pool: <%= ENV.fetch("RAILS_MAX_THREADS") { 5 } %>
  timeout: 5000

development:
  <<: *default
  database: storage/development.sqlite3

test:
  <<: *default
  database: storage/test.sqlite3

production:
  primary:
    <<: *default
    database: storage/production.sqlite3
  cache:
    <<: *default
    database: storage/production_cache.sqlite3
    migrations_paths: db/cache_migrate
  queue:
    <<: *default
    database: storage/production_queue.sqlite3
    migrations_paths: db/queue_migrate
  cable:
    <<: *default
    database: storage/production_cable.sqlite3
    migrations_paths: db/cable_migrate
```

### 1.7 データベースの作成とマイグレーション

```bash
bundle exec rails db:create
bundle exec rails db:migrate
```

### 1.8 ローカル環境での動作確認

```bash
bundle exec rails s
```

ブラウザでlocalhost:3000を開くとPost一覧が表示されます。

## 2. Dockerfileの作成

プロジェクトのルートディレクトリに`Dockerfile`を作成します：

```dockerfile
FROM --platform=linux/x86_64 ruby:3.2-slim AS base

WORKDIR /rails

# システムの依存関係をインストール
RUN apt-get update -qq && \
    apt-get install --no-install-recommends -y build-essential libvips pkg-config libsqlite3-dev

# アプリケーションの依存関係
COPY Gemfile Gemfile.lock ./
RUN bundle install

# アプリケーションコードをコピー
COPY . .

# データベースディレクトリを作成
RUN mkdir -p storage

# アセットのプリコンパイル
RUN bundle exec rails assets:precompile

# 起動スクリプト
COPY bin/docker-entrypoint /rails/bin/docker-entrypoint
RUN chmod +x /rails/bin/docker-entrypoint

ENV RAILS_ENV=production
ENV RAILS_SERVE_STATIC_FILES=true
ENV RAILS_LOG_TO_STDOUT=true

EXPOSE 3000

ENTRYPOINT ["/rails/bin/docker-entrypoint"]
CMD ["bundle", "exec", "rails", "server", "-b", "0.0.0.0"]
```

### 2.1 Docker起動スクリプトの作成

`bin/docker-entrypoint`ファイルを作成します：

```bash
#!/bin/bash
set -e

# データベースマイグレーションを実行
bundle exec rails db:migrate

# 引数のコマンドを実行
exec "$@"
```

## Cloud RunとDockerfileのポート設定について

### Dockerfileでのポート設定

Dockerfileを確認すると、以下の設定があります：

```
# Start server via Thruster by default, this can be overwritten at runtime
EXPOSE 80
CMD ["./bin/thrust", "./bin/rails", "server"]
```

ここでの`EXPOSE 80`は、コンテナがポート80でリッスンすることを「宣言」しています。これは単なるドキュメンテーションであり、実際にポートを開放するわけではありません。

### Thrusterの役割

アプリケーションでは、Thrusterというプロキシサーバーを使用しています：

```
CMD ["./bin/thrust", "./bin/rails", "server"]
```

Thrusterはデフォルトでポート80でリッスンし、内部的にはRailsアプリ（Puma）のポート3000にリクエストを転送します。

### Pumaの設定

`config/puma.rb`では、Pumaのリッスンポートが設定されています：

```ruby
# Specifies the `port` that Puma will listen on to receive requests; default is 3000.
port ENV.fetch("PORT", 3000)
```

### Cloud Runでのポート設定の意味

Cloud Runでコンテナポートを`3000`に設定する理由：

1. **コンテナ内の実際のリッスンポートを指定する**
   - Thrusterを使用しない場合、Railsアプリ（Puma）は直接ポート3000でリッスンします
   - この場合、Cloud Runの設定でポート3000を指定する必要があります

2. **Thrusterを使用する場合**
   - Thrusterがポート80でリッスンし、内部的にPumaのポート3000にリクエストを転送します
   - この場合、Cloud Runの設定でポート80を指定する必要があります

### エラーが発生するケース

以下の場合にエラーが発生する可能性があります：

1. **ミスマッチのケース**
   - アプリが3000番でリッスンしているのに、Cloud Runで8080を指定した場合
   - Thrusterが80番でリッスンしているのに、Cloud Runで3000を指定した場合

2. **典型的なエラーメッセージ**
   - 「コンテナへの接続が確立できません」
   - 「ヘルスチェックに失敗しました」

### 正しい設定方法

1. **Thrusterを使用する場合**
   - Dockerfile: `EXPOSE 80`
   - Cloud Run設定: コンテナポート = `80`

2. **Thrusterを使用しない場合（直接Pumaを使用）**
   - Dockerfile: `EXPOSE 3000`
   - Cloud Run設定: コンテナポート = `3000`

Cloud Runは指定されたポートにトラフィックを転送するため、コンテナ内のアプリケーションが実際にリッスンしているポートと一致させることが重要です。

## 3. Google Cloudの設定

### ✅3.1 Cloud Storageバケットの作成

1. Google Cloudコンソールで「Cloud Storage」に移動
2. 「バケットを作成」をクリック
3. バケット名を入力：`weight-tracker`
4. リージョンを選択：`asia-northeast1`
5. 「作成」をクリック

### ✅3.2 Secret ManagerにMaster Keyを保存

1. Google Cloudコンソールで「Secret Manager」に移動
2. 「シークレットを作成」をクリック
3. 名前に`rails_master_key`と入力
4. シークレット値に`config/master.key`の内容を入力
5. 「作成」をクリック

### ✅3.3 サービスアカウントに権限を付与

Cloud RunからSecret Managerにアクセスするために、デフォルトのサービスアカウントにSecret Managerアクセサーロールを付与します：

1. Google Cloudコンソールで「IAM」に移動
2. プロジェクトのデフォルトのCompute Engine サービスアカウントを見つける
3. 編集ボタンをクリック
4. 「別のロールを追加」をクリック
5. 「Secret Managerのシークレットアクセサー」を選択
6. 「保存」をクリック

### ✅3.4 Artifact Repositoryの準備

1. Google Cloudコンソールで「Artifact Registry」に移動
2. 「リポジトリを作成」をクリック
3. 名前を入力（例：`weight-tracker-repo`）
4. フォーマットに「Docker」を選択
5. リージョンを選択（例：`asia-northeast1`）
6. 「作成」をクリック

## 4. Dockerイメージのビルドとプッシュ

### ✅4.1 Google Cloudにログイン

```bash
gcloud auth login
```

このコマンドはGoogle Cloudにログインするためのものです。実行すると、ブラウザが開き、Googleアカウントでの認証が求められます。認証が成功すると、gcloudコマンドラインツールがあなたのアカウント権限でGoogle Cloudリソースにアクセスできるようになります。

### ✅4.2 Artifact Repositoryの認証設定


```bash
gcloud auth configure-docker asia-northeast1-docker.pkg.dev
```

このコマンドは、Dockerクライアントが東京リージョン（asia-northeast1）のGoogle Cloud Artifact Registryにアクセスするための認証設定を行います。これにより、Dockerコマンドを使ってコンテナイメージをプッシュ（アップロード）やプル（ダウンロード）する際に、自動的にGoogle Cloudの認証情報が使用されるようになります。

### ✅4.3 環境変数の設定

```bash
PROJECT_ID=weight-tracker-466722
REPOSITORY_NAME=weight-tracker-repo
SERVICE_NAME=weight-tracker
```

これらの環境変数を設定することで、以降のコマンドで繰り返し使用する値を簡単に参照できるようになります：
- PROJECT_ID：Google Cloudプロジェクトの一意のID
- REPOSITORY_NAME：Artifact Registryに作成したリポジトリ名
- SERVICE_NAME：デプロイするアプリケーション/サービスの名前

### ✅4.4 イメージのビルド

```bash
docker build -t asia-northeast1-docker.pkg.dev/$PROJECT_ID/$REPOSITORY_NAME/$SERVICE_NAME:1 .
```

このコマンドは、カレントディレクトリ（.）にあるDockerfileを使用してDockerイメージをビルド（構築）します。`-t`オプションでイメージにタグ名を付けています。タグ名は、Artifact Registryの命名規則に従っており、後でイメージをプッシュする際の宛先を指定しています。`:1`はイメージのバージョン番号を表します。

### ✅4.5 イメージのプッシュ

```bash
docker push asia-northeast1-docker.pkg.dev/$PROJECT_ID/$REPOSITORY_NAME/$SERVICE_NAME:1
```

このコマンドは、ローカルでビルドしたDockerイメージをGoogle CloudのArtifact Registryにアップロード（プッシュ）します。アップロードされたイメージは、Cloud Runなどのサービスからアクセスできるようになり、アプリケーションのデプロイに使用されます。

## 5. Cloud Runへのデプロイ

1. Google Cloudコンソールで「Cloud Run」に移動
2. 「サービスを作成」をクリック
3. 「既存のコンテナイメージ」を選択
4. 先ほどプッシュしたイメージを選択
5. サービス名を入力（例：`myapp`）
6. リージョンを選択（例：`asia-northeast1`）
7. 「認証」を「未認証の呼び出しを許可」に設定
8. 「コンテナ」タブでコンテナポートを`3000`に設定
9. 「ボリューム」タブで新しいボリュームを追加：
   - ボリュームタイプ：Cloud Storageバケット
   - ボリューム名：database
   - バケット：先ほど作成したバケット
10. 「コンテナ」タブに戻り、「ボリュームのマウント」でマウントパスを`/rails/storage`に設定
11. 「変数とシークレット」タブで、Secret Managerから`RAILS_MASTER_KEY`を追加
12. 「リビジョンスケーリング」でインスタンスの最小数を`0`、最大数を`1`に設定
13. 「作成」をクリック

## 6. Firebase Hostingの設定

### 6.1 Firebase CLIのインストール（未インストールの場合）

```bash
npm install -g firebase-tools
```

### 6.2 Firebaseにログイン

```bash
firebase login
```

### 6.3 プロジェクトの初期化

```bash
firebase init
```

以下の選択肢を選びます：
- Hostingを選択
- 既存のプロジェクトを使用
- パブリックディレクトリとして`public`を指定
- シングルページアプリケーションとして設定するかどうかは「No」

### 6.4 カスタムドメインの設定（オプション）

Firebase Hostingでカスタムドメインを設定する場合：

1. Firebaseコンソールで「Hosting」に移動
2. 「カスタムドメイン」をクリック
3. ドメイン名を入力
4. 指示に従ってDNSレコードを設定

### 6.5 Cloud RunとFirebase Hostingの連携

Firebase Hostingから Cloud Runへのリクエストを転送するために、`firebase.json`を編集します：

```json
{
  "hosting": {
    "public": "public",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "run": {
          "serviceId": "myapp",
          "region": "asia-northeast1"
        }
      }
    ]
  }
}
```

### 6.6 静的ファイルの準備

`public`ディレクトリに、必要な静的ファイルを配置します。例えば、`index.html`を作成：

```html
<!DOCTYPE html>
<html>
<head>
  <title>My Rails App</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
</head>
<body>
  <h1>Welcome to My Rails App</h1>
  <p>This is served by Firebase Hosting!</p>
</body>
</html>
```

### 6.7 Firebaseへのデプロイ

```bash
firebase deploy
```

## 7. 動作確認

### 7.1 Cloud Runの確認

Cloud Runのデプロイが成功すると、サービスURLが表示されます。このURLにアクセスして、Railsアプリケーションが正しく動作していることを確認します。

### 7.2 Firebase Hostingの確認

Firebase Hostingのデプロイが成功すると、ホスティングURLが表示されます。このURLにアクセスして、静的ファイルとRailsアプリケーションが正しく連携していることを確認します。

### 7.3 Cloud Storageの確認

Cloud Storageのバケットを確認し、SQLiteのデータベースファイルが正しく作成されていることを確認します。

## 8. 費用と制限事項

### 8.1 費用目安

- **Cloud Run**: 無料枠（180,000 vCPU秒、360,000 GiB秒、200万リクエスト/月）内であれば無料
- **Cloud Storage**: 無料枠（5GB）内であれば無料
- **Firebase Hosting**: 無料枠（10GB転送/月）内であれば無料
- **Artifact Registry**: 無料枠（0.5GB）を超えると少額課金（月数円程度）

### 8.2 制限事項

- **スケールアウトの制限**: SQLiteが単一ホスト前提のため、Cloud Runの水平スケーリング機能は使えません
- **コールドスタート**: しばらくアクセスがない場合、約20秒の起動時間がかかります
- **大規模アプリには不向き**: トラフィックが多いアプリケーションには向いていません

## 9. まとめ

Rails 8でSQLiteを本番環境で使用し、Google CloudのCloud RunとCloud Storage、そしてFirebase Hostingを組み合わせることで、ほぼ無料でRailsアプリケーションを運用することができます。この構成は、デモ用の小規模アプリやポートフォリオ用アプリなど、トラフィックが少なく、コスト効率を重視する場合に適しています。

## 10. ハマったポイント
### 10.1 デプロイ時に`terminated: Application failed to start: "/rails/bin/docker-entrypoint": exec format error`でエラー
理由：Dockerイメージがビルドされたシステムと実行されるシステムのCPUアーキテクチャの不一致で発生する
参考：https://blog.g-gen.co.jp/entry/introduction-to-cloud-run-service
解決策：Dockerfileに`FROM --platform=linux/x86_64 docker.io/library/ruby:$RUBY_VERSION-slim AS base`でプラットフォーム指定
Cloud buildでもデプロイ可能（上記記事参考）→API有効化を忘れずに！
```
gcloud builds submit --tag asia-northeast1-docker.pkg.dev/$PROJECT_ID/$REPOSITORY_NAME/$SERVICE_NAME:1
```
### 10.2 ポート指定
DockerコンテナのポートとCloud run側のポートを一致させる必要があった

### 10.3 その他
デプロイ成功後に下記エラーが出た
- ブラウザで'Error: Forbidden
Your client does not have permission to get URL / from this server.'
  →Cloud Runの「未認証の呼び出しを許可」設定をONにする必要があった
- ブラウザで500 Internal Server Error
  →Cloud RunでSQLiteを使うと、データが消える・保存されない・初期化されるなどの問題が起きる可能性があるらしい。DockerfileのCMDに`rails db:migrate`を追記

## 参考リンク

- [Rails 8で本番利用可能になったSQLiteをつかうとGoogle Cloudでほぼ無料で運用ができそうな件](https://zenn.dev/kiyokato/articles/6d4b6f629768b7)
- [Firebase Hostingのドキュメント](https://firebase.google.com/docs/hosting)
- [Cloud Runのドキュメント](https://cloud.google.com/run/docs) 
